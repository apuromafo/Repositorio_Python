import os
import re
import math
import csv
import argparse
from pathlib import Path

# === FUNCIONES DE DETECCI√ìN Y CLASIFICACI√ìN === #

def detectar_complejidad(password):
    """Detecta qu√© tipos de caracteres contiene la contrase√±a."""
    return {
        'digitos': any(c.isdigit() for c in password),
        'mayusculas': any(c.isupper() for c in password),
        'minusculas': any(c.islower() for c in password),
        'especiales': any(not c.isalnum() and not c.isspace() for c in password)
    }

def calcular_entropia(longitud, complejidad):
    """Calcula la entrop√≠a en bits de una contrase√±a."""
    num_caracteres = sum([
        10 if complejidad['digitos'] else 0,
        26 if complejidad['mayusculas'] else 0,
        26 if complejidad['minusculas'] else 0,
        32 if complejidad['especiales'] else 0  # Aproximado
    ])
    if num_caracteres == 0:
        return 0
    return longitud * math.log2(num_caracteres)

def clasificar_entropia(entropia):
    """Clasifica la entrop√≠a de la contrase√±a."""
    if entropia < 41:
        return "Muy D√©bil"
    elif entropia < 61:
        return "D√©bil"
    elif entropia < 81:
        return "Moderada"
    elif entropia < 101:
        return "Fuerte"
    else:
        return "Muy Fuerte"

# === PATRONES DE PARSEO === #

def parse_line(line):
    line = line.strip()
    line = re.sub(r'\s+', ' ', line).strip()
    if ';' in line:
        line = line.replace(';', ':')

    # Caso nuevo: correo:clave
    email_pass_match = re.match(
        r"([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})\:([\w\-\.!@#$%^&*()]+)",
        line
    )
    if email_pass_match:
        clave = email_pass_match.group(2)
        complejidad = detectar_complejidad(clave)
        entropia = calcular_entropia(len(clave), complejidad)
        return {
            "Sitio": "[Sin sitio]",
            "Usuario": email_pass_match.group(1),
            "Clave": clave,
            "Patr√≥n": "Email:Clave",
            "Entrop√≠a": round(entropia, 2),
            "Fuerza": clasificar_entropia(entropia)
        }

    # Caso general: usuario:clave
    user_pass_match = re.match(
        r"^([\w\-.@]+)\:([\w\-\.!@#$%^&*()\[\]]+)$",
        line
    )
    if user_pass_match and ":" in line and line.count(":") == 1:
        clave = user_pass_match.group(2).strip('[]')
        complejidad = detectar_complejidad(clave)
        entropia = calcular_entropia(len(clave), complejidad)
        return {
            "Sitio": "[Desconocido]",
            "Usuario": user_pass_match.group(1),
            "Clave": clave,
            "Patr√≥n": "Usuario:Clave",
            "Entrop√≠a": round(entropia, 2),
            "Fuerza": clasificar_entropia(entropia)
        }

    # Otros casos ya definidos...

    # Ignorar l√≠neas vac√≠as o con "$:$"
    if re.search(r".*\:\$\:.*", line) or re.search(r"::$", line):
        return None

    return None

# === PROCESAMIENTO DEL ARCHIVO === #

def process_file(filepath):
    parsed_entries = []
    unparsed_lines = []

    try:
        with open(filepath, 'r', encoding='utf-8') as f:
            lines = f.readlines()
    except Exception as e:
        print(f"[ERROR] No se pudo leer el archivo: {filepath} | Error: {e}")
        return [], []

    for i, line in enumerate(lines):
        line = line.strip()
        if not line:
            continue
        result = parse_line(line)
        if result:
            parsed_entries.append(result)
        else:
            unparsed_lines.append(f"L√≠nea {i + 1}: {line}")

    return parsed_entries, unparsed_lines

# === BUSQUEDA RECURSIVA EN CARPETAS === #

def find_files_in_folder(folder_path, extensions=[".txt", ".log", ".sql", ".csv"]):
    files_to_process = []
    for root, _, files in os.walk(folder_path):
        for file in files:
            if any(file.endswith(ext) for ext in extensions):
                files_to_process.append(os.path.join(root, file))
    return files_to_process

# === GUARDADO DE RESULTADOS === #

def contar_por_categoria(entries):
    categorias = {
        "Muy D√©bil": 0,
        "D√©bil": 0,
        "Moderada": 0,
        "Fuerte": 0,
        "Muy Fuerte": 0
    }
    for entry in entries:
        categoria = entry.get("Fuerza", "Desconocido")
        if categoria in categorias:
            categorias[categoria] += 1
    return categorias

def grafico_ascii(categorias):
    max_bar_length = 40
    total = sum(categorias.values())
    print("\nüìä Gr√°fico de barras de fuerza de contrase√±as:")
    for cat, count in categorias.items():
        percent = count / total if total else 0
        bar_len = int(max_bar_length * percent)
        bar = '#' * bar_len + '-' * (max_bar_length - bar_len)
        print(f"{cat.rjust(10)} | {bar} {count} ({percent:.1%})")

def save_results(entries, errors, txt_output="salida.txt", csv_output="salida.csv"):
    # A√±adir ID √∫nico a cada entrada
    for idx, entry in enumerate(entries):
        entry["ID"] = idx + 1

    with open(txt_output, "w", encoding="utf-8") as f:
        f.write("=== CREDENCIALES FILTRADAS ===\n\n")
        for entry in entries:
            f.write(f"ID: {entry['ID']}\n")
            f.write(f"Sitio: {entry['Sitio']}\n")
            f.write(f"Usuario: {entry['Usuario']}\n")
            f.write(f"Clave: {entry['Clave']}\n")
            f.write(f"Patr√≥n: {entry['Patr√≥n']}\n")
            f.write(f"Entrop√≠a: {entry['Entrop√≠a']} bits\n")
            f.write(f"Fuerza: {entry['Fuerza']}\n")
            f.write("-" * 60 + "\n")

        # Resumen por categor√≠a
        categorias = contar_por_categoria(entries)
        f.write("\n=== RESUMEN DE CONTRASE√ëAS POR NIVEL ===\n\n")
        for categoria, cantidad in categorias.items():
            f.write(f"{categoria}: {cantidad}\n")

        # L√≠neas no procesadas
        f.write("\n=== L√çNEAS NO PROCESADAS ===\n")
        for error in errors:
            f.write(f"{error}\n")

    print(f"\n‚úÖ Se han procesado {len(entries)} credenciales.")
    print(f"‚ùå No se pudieron procesar {len(errors)} l√≠neas.")

    grafico_ascii(categorias)

    print("\nüìä Resumen por nivel de seguridad:")
    for categoria, cantidad in categorias.items():
        print(f"{categoria}: {cantidad}")

    if csv_output:
        with open(csv_output, "w", newline="", encoding="utf-8") as f:
            writer = csv.DictWriter(f, fieldnames=["ID", "Sitio", "Usuario", "Clave", "Patr√≥n", "Entrop√≠a", "Fuerza"])
            writer.writeheader()
            writer.writerows(entries)
        print(f"üìÑ Datos tambi√©n guardados en: {csv_output}")

# === FUNCI√ìN PRINCIPAL CON ARGPARSE === #

def main():
    parser = argparse.ArgumentParser(description="Analiza archivos o carpetas en busca de credenciales filtradas.")
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument('-a', '--archivo', type=str, help='Ruta al archivo .txt, .log, .sql, etc.')
    group.add_argument('-f', '--folder', type=str, help='Ruta a la carpeta con archivos potencialmente sensibles')
    args = parser.parse_args()

    all_parsed_entries = []
    all_unparsed_lines = []

    if args.archivo:
        print(f"\nüîç Procesando archivo: {args.archivo}")
        entries, errors = process_file(args.archivo)
        all_parsed_entries.extend(entries)
        all_unparsed_lines.extend(errors)
    elif args.folder:
        print(f"\nüìÅ Buscando archivos en carpeta: {args.folder}")
        files = find_files_in_folder(args.folder)
        if not files:
            print("‚ùå No se encontraron archivos v√°lidos en esta carpeta.")
            return
        for file in files:
            print(f"üìÑ Procesando archivo: {file}")
            entries, errors = process_file(file)
            all_parsed_entries.extend(entries)
            all_unparsed_lines.extend(errors)

    save_results(all_parsed_entries, all_unparsed_lines)

    if all_unparsed_lines:
        print("\n‚ùå L√≠neas que no se pudieron procesar:")
        for error in all_unparsed_lines:
            print(error)
    else:
        print("\n‚úÖ ¬°Todas las l√≠neas fueron procesadas exitosamente!")

    print("\nFinalizado.")

if __name__ == "__main__":
    main()